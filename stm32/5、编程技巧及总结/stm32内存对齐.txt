对于stm32的内存操作，尤其是高级指针操作，内存的对齐直接关乎系统的正常与否。
如：
定义一个数组        
u16                PLC_Reg_4X[256] = {0};        //保持寄存器

在定义一个结构体
typedef struct {
        float rated_frequency;
        float rated_voltage;
        float rated_current;
        float rated_power_factor;
}rated_typedef;

然后定义一个rated_typedef的指针指向PLC_Reg_4X数组
rated_typedef *ratedGG=(rated_typedef *)&PLC_Reg_4X[52];，指向数组的偶数元素。

就这样，我们理论上可以通过ratedGG指针来操作数组的元素了，但是仅仅是理论层面。实际过程中将出现各种奇怪的问题。

我们首先来分析一下，对于嵌入式系统而言，有些支持非对齐的数据访问，有的不支持。如stm32是支持非对齐的数据访问的。
我们继续分析。 PLC_Reg_4X[256];数组是uint16_t型，因此编译器默认2字节对齐，这个的原因在于编译器。
如：网友解释的
u8  array[n]; // 这是1字节对齐的，与n取值无关。
u16 array[n]; // 这是2字节对齐的，与n取值无关。
u32 array[n]; // 这是4字节对齐的，与n取值无关。
你把u16型数组的长度改为256可用，那仅仅是连接器的偶然，知识要严谨不能依赖偶然；既然整个数组的起始地址不能保证是4字节对齐，你在此数组的52索引处也同样不能保证4字节对齐。
而你定义的结构体必须4字节对齐，因为其成员是float类型。

故rated_typedef类型必须4字节对齐解析，而数组PLC_Reg_4X编译器只能保证2字节对齐，因此解析的时候会出现问题。
因此必须强制数组PLC_Reg_4X四字节对齐及加上__align(4)


什么时候会出现内存对齐的问题？
答案是：指针的强制类型转换的时候，在这个时候我们需要明确转换的过程中不能将低内存对齐的变量或者数据强制转换
为高内存对齐的数据类型。




